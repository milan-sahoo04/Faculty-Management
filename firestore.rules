rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper to get auth status
    function isAuthenticated() {
      return request.auth != null;
    }

    // Helper to check if the user is a member of the provided data
    function isMember(data) {
      return isAuthenticated() && data.members[request.auth.uid] == true;
    }

    // Helper for Admin Oversight: User is Admin AND chat is 'support'
    function isAdminOversight(data) {
      // NOTE: request.auth.token.role requires a custom claim on the user token.
      return isAuthenticated() && request.auth.token.role == 'admin' && data.chatType == 'support';
    }
    
    // Function to check membership in the parent chat document
    function isParentChatMember(chatId) {
      return isMember(get(/databases/$(database)/documents/chats/$(chatId)).data);
    }

    // --- 0. User Profile Rules (Needed for custom claims/roles) ---
    match /users/{userId} {
      allow read, write: if isAuthenticated() && request.auth.uid == userId;
    }


    // ===================================================================
    // 1. CHAT ROOM COLLECTION RULES (/chats/{chatId})
    // ===================================================================
    match /chats/{chatId} {
      // Allow read for members and Admin Oversight
      allow read: if isMember(resource.data) || isAdminOversight(resource.data);

      // Allow create: Only when setting up the initial document (e.g., in sendMessage)
      allow create: if isAuthenticated()
                      // Must include the current user as a member
                      && request.resource.data.members[request.auth.uid] == true
                      // Enforce minimal required schema
                      && request.resource.data.keys().hasAll(['members', 'chatType', 'createdAt']);
                      
      // Allow update: Only to members, and ONLY for non-critical fields (like lastMessage info, if you were using it)
      // Since your component only sets the doc once, we can keep this simple, or even disallow it.
      // We'll simplify to allow members to update (for future metadata changes) without changing members/type.
      allow update: if isMember(resource.data) 
                      && request.resource.data.members == resource.data.members
                      && request.resource.data.chatType == resource.data.chatType;
    }
    
    // ===================================================================
    // 2. MESSAGES SUBCOLLECTION RULES (/chats/{chatId}/messages/{messageId})
    // ===================================================================
    match /chats/{chatId}/messages/{messageId} {
      
      // Allow read: If the user is a member of the PARENT chat document (covers both regular members and Admin Oversight if they are added as a member)
      // NOTE: For Admin Oversight, the Admin is NOT a member of student chats, so the rule needs to rely on the top-level chat READ rule, which works for list but not for direct message read.
      // We must check if the user can read the parent chat.
      allow read: if get(/databases/$(database)/documents/chats/$(chatId)).data.members[request.auth.uid] == true
                  || isAdminOversight(get(/databases/$(database)/documents/chats/$(chatId)).data);

      // Allow create: Only if the user is a member of the PARENT chat document
      allow create: if isParentChatMember(chatId)
                      // Ensure the sender is the authenticated user
                      && request.resource.data.senderId == request.auth.uid
                      // Enforce schema
                      && request.resource.data.keys().hasAll(['senderId', 'senderName', 'message', 'timestamp']);
    }
  }
}